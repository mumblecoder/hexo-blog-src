---
title: 트랜잭션 처리를 위한 어노테이션 @Transactional
date: 2020-01-03 16:30:08
tags: [annotation, transaction]
categories: spring
---
` 기존 코드에 API를 호출하여 다른 처리를 하는 기능을 추가하는데 API쪽에서 DB값을 못 읽어오는 에러가 발생했다. 찾다보니 API Call 직전에 insert된 값을 가져와야 하는데 전체에 transaction이 걸려있어서 API 쪽에서는 commit이 안된 값이라 읽어 올 수가 없었다.`

그래서 @transactional에 대해서 공부하기로!

#### 먼저 트랜잭션의 성질!

**원자성(Atomicity)** - 한 트랜잭션 내에서 실행한 작업들은 하나로 간주한다. 즉, 모두 성공 또는 모두 실패. 

**일관성(Consistency)** - 트랜잭션은 일관성 있는 데이타베이스 상태를 유지한다. (data integrity 만족 등.)

**격리성(Isolation)** - 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리해야한다.

**지속성(Durability)** - 트랜잭션을 성공적으로 마치면 결과가 항상 저장되어야 한다.


#### 다음은 다수의 트랜잭션이 존재할 때 발생할 수 있는 문제!

`Dirty Read`
 - 트랜잭션 A가 어떤 값을 1에서 2로 변경하고 아직 커밋하지 않은 상황에서 트랜잭션B가 같은 값을 읽는 경우 트랜잭션 B는 2가 조회 된다.
 - 트랜잭션 B가 2를 조회 한 후 혹시 A가 롤백된면 결국 트랜잭션B는 잘못된 값을 읽게 된 것이다. 즉, 아직 트랜잭션이 완료되지 않은 상황에서 데이터에 접근을 허용할 경우 발생할 수 있는 데이터 불일치이다.

`Non-Repeatable Read`
 - 트랜잭션 A가 1을 읽었다. 이후 A는 같은 쿼리를 또 실행할 예정인데, 그 사이에 트랜잭션 B가 값 1을 2로 바꾸고 커밋해버리면 A가 두번째 쿼리를 날렸을시 이전과 다른 값을 읽게 된다.
 - 즉, 한 트랜잭션에서 같은 쿼리를 두번 실행했을 때 발생할 수 있는 데이터 불일치이다. Dirty Read에 비해서는 발생 확률이 적다.

`Phantom Read`
 - 트랜잭션 A가 [0,1,2,3,4]을 읽었다. 이후 A는 같은 쿼리를 실행할 예정인데, 그 사이에 트랜잭션 B가 같은 테이블에 값[5,6,7]을 추가해버리면 A가 두번째 쿼리를 날렸을시 이전과 다른 값을 읽게 된다.
 - 즉, 한 트랜잭션에서 일정 레코드를 여러번 읽을 때 발생하는 데이터 불일치이다.
 
 
 
